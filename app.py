#!/usr/bin/env python3

#            +++++++++++++++++++++++++++++++++++++++++++
#            +              TLShark main               +
#            +           ------------------            +
#            +             A testing tool              +
#            +                   by                    +
#            +        Victor M Molinos Santiago        +
#            +++++++++++++++++++++++++++++++++++++++++++


## LIBRARIES
###------------------------------------------------------------------------------------------------------------------------------------
from cgitb import reset
import os
import json
import signal
import time
import textwrap
import argparse
import datetime
import subprocess
import pyshark as psk
from tabulate import tabulate
import tlshark.functions as func


def main():


    ## CLI
    ###------------------------------------------------------------------------------------------------------------------------------------
    parser = argparse.ArgumentParser(
        prog="TLShark",
        formatter_class=argparse.MetavarTypeHelpFormatter,
        usage=textwrap.dedent("""\


             ______  __       ____    __                       __         
            /\__  _\/\ \     /\  _`\ /\ \                     /\ \        
            \/_/\ \/\ \ \    \ \,\L\_\ \ \___      __     _ __\ \ \/'\    
               \ \ \ \ \ \  __\/_\__ \\\ \  _ `\  /'__`\  /\`'__\ \ , <    
                \ \ \ \ \ \L\ \ /\ \L\ \ \ \ \ \/\ \L\.\_\ \ \/ \ \ \\\`\  
                 \ \_\ \ \____/ \ `\____\ \_\ \_\ \__/.\_\\\ \_\  \ \_\ \_\\
                  \/_/  \/___/   \/_____/\/_/\/_/\/__/\/_/ \/_/   \/_/\/_/


            {*} VERBOSE MODE:   Sniff a net, extract tls handshake messajes information and show 
                                it for each packet.
                                
            {*} CERLOG MODE:    Collect information from tls handshake messages in a client-server 
                                connection, clone the certificates (same CA (if exists) but other 
                                public key) and store it all in a json file.
                                
            {*} ROGUE MODE:     Choose one of the targets stored by the Cerlog mode and raise a 
                                impersonation server with the cloned certificate. You can also load 
                                the server data from a json file generated by Cerlog mode.
                                
            {*} TRANSPARENT MITMPROXY MODE: Choose one of the targets stored by the Cerlog mode and 
                                            raise a transparent man-in-the-middle proxy with a 
                                            mitmproxy certificate or a Apostille cloned certificate. 
                                            Also you can load the proxy data from a json file generated 
                                            by Cerlog mode.
                                            
            {*} REVERSE MITMPROXY MODE:     Raise a reverse man-in-the-middle proxy for a given url. 
            
            {*} TLS VERSION DETECTOR MODE:  It discovers the tls version of a computer with the help of 
                                            a server that collects the requests sent by this computer. 
                                            The server switches between tls versions until it finds the 
                                            version that matches the device's requests. 
                                  
                                                      
            
            VERBOSE: [-i, -sp, -ip, -sip, -cip, -client/-server/-all, -c, -pcap]
            CERLOG: [-i, -sp, -sip, -cip -pcap]
            ROGUE: [-json]
            TRANSPARENT MITMPROXY: [-i, -json, -certfrom_tlshark/-certfrom_mitmproxy/-certfrom_path]
            REVERSE MITMPROXY: [-url]
            TLS VERSION DETECTOR: [-json]
     
            
            Examples:
            $ tlshark -verbose -all -c -cip 192.168.74.132 -pcap /path/to/capture.pcap
            $ tlshark -cerlog -i any -sp 80 -cip 192.168.74.134 -pcap path/to/file.pcap 
            $ tlshark -rogue 
            $ tlshark -trp_mitmproxy -certfrom_tlshark
            $ tlshark -rev_mitmproxy -url www.example.com
            $ tlshark -tls_vdetector
            """
        )
    )
    parser.add_argument('-v','--version', action='version', version='%(prog)s 1.0')
    parser.add_argument('-verbose', action='store_const', default=0, const=1, help=("Verbose mode.")) 
    parser.add_argument('-cerlog', action='store_const', default=0, const=1, help=("Cerlog mode."))
    parser.add_argument('-rogue', action='store_const', default=0, const=1, help=("Rogue mode."))
    parser.add_argument('-trp_mitmproxy', action='store_const', default=0, const=1, help=("Transparent Mitmproxy mode."))
    parser.add_argument('-rev_mitmproxy', action='store_const', default=0, const=1, help=("Reverse Mitmproxy mode."))
    parser.add_argument('-tls_vdetector', action='store_const', default=0, const=1, help=("TLS Version Detector mode."))
    parser.add_argument('-i', type=str, default="eth0" ,help=("Ethernet interface. (Default: eth0)"))
    parser.add_argument('-sp', type=str, default='' ,help=("TCP Server port.")) 
    parser.add_argument('-sip', type=str, default='', help=("Server IP."))
    parser.add_argument('-cip', type=str, default='', help=("Client IP."))
    parser.add_argument('-ip', type=str, default='', help=("Address IP.")) 
    parser.add_argument('-client', action='store_const', default=0, const=1, help=("Client info."))
    parser.add_argument('-server', action='store_const', default=0, const=1, help=("Server info.")) 
    parser.add_argument('-all', action='store_const', default=0, const=1, help=("All Client and Server info."))
    parser.add_argument('-c', action='store_true', default=False, help=("Extract certificate info."))  
    parser.add_argument('-pcap', type=str, default= '', help=("pcap mode. Analyze from a capture.pcap.")) 
    parser.add_argument('-json', type=str, default= '', help=("json mode. Raise a server or a proxy from a specific json file.")) 
    parser.add_argument('-certfrom_tlshark', action='store_const', default=0, const=1, help=("Uses a certificate cloned by Apostille in Transparent Mitmproxy mode."))
    parser.add_argument('-certfrom_mitmproxy', action='store_const', default=0, const=1, help=("Uses a self-signed certificate by mitmproxy in Transparent Mitmproxy mode."))
    parser.add_argument('-certfrom_path', type=str, default='', help=("Uses a certificate hosted in a path in Transparent Mitmproxy mode."))
    parser.add_argument('-url', type=str, default='', help=("Set the https url in Reverse Mitmproxy mode. Example: -url www.example.com"))

    args = parser.parse_args()
    mode = str(args.verbose) + str(args.cerlog) + str(args.rogue) + str(args.trp_mitmproxy) + str(args.rev_mitmproxy) + str(args.tls_vdetector) 
    # '100000'-Verbose mode -- '010000'-Cerlog mode -- '001000'-Rogue mode -- '000100'-Transparent Mitmproxy mode -- '000010'-Reverse Mitmproxy mode -- '000100'-TLS Version Detector mode.
    
    aux_info = str(args.client) + str(args.server) + str(args.all) 
            # '100'-Client info -- '010'-Server Info -- '001'-All info. 

    digit_tlshark = 0
    if args.certfrom_tlshark:
        digit_tlshark = 1
    digit_mitmproxy = 0
    if args.certfrom_mitmproxy:
        digit_mitmproxy = 1
    digit_path = 0
    if args.certfrom_path:
        digit_path = 1

    certfrom_mode = str(digit_tlshark) + str(digit_mitmproxy) + str(digit_path) # '100' - certfrom_tlshark -- '010' - certfrom_mitmproxy -- '001' - certfrom_path. 


    ## LOCATIONS
    ###------------------------------------------------------------------------------------------------------------------------------------
    json_path ="./tlshark_json/" # json folder path.
    pcap_path = args.pcap # pcap_path. 
    tmp_tlshark_path = "/tmp/tlshark_tmp" # tlshark temporal folder.
    tmp_captured_path = tmp_tlshark_path + "/captured_certs/" # Captured certificates temporal folder.
    tmp_cloned_path = tmp_tlshark_path + "/cloned_certs/" # Cloned certificates temporal folder.




    ## COLORS
    ###------------------------------------------------------------------------------------------------------------------------------------
    reset_color = func.colors('reset',0)
    grey = func.colors('grey',0)
    red = func.colors('red',0)
    green = func.colors('green',0)
    yellow = func.colors('yellow',0)
    blue = func.colors('blue',0)  
    cian = func.colors('cian',0)
    purple = func.colors('purple',0)
    white= func.colors('white',0)

    reset_undercolor = func.colors('reset',1)
    undergrey = func.colors('grey',1)
    underred = func.colors('red',1)
    undergreen = func.colors('green',1)
    underyellow = func.colors('yellow',1)
    underblue = func.colors('blue',1)
    undercian = func.colors('cian',1)
    underpurple = func.colors('purple',1)
    underwhite= func.colors('white',1)




    ## OPERATING MODES
    ###------------------------------------------------------------------------------------------------------------------------------------
    print('\n')
    func.operating_modes(mode,aux_info,args.c,pcap_path,args.json,certfrom_mode,args.url)




    ## CIPHER CLASSIFICATION DICTIONARY
    ###------------------------------------------------------------------------------------------------------------------------------------
    dictionary = func.dictionary()




    ## INTERFACE FILTER
    ###------------------------------------------------------------------------------------------------------------------------------------ 
    eth_interface = args.i




    ## GENERATING NECESSARY DIRECTORIES
    ###------------------------------------------------------------------------------------------------------------------------------------
    try:
        os.mkdir(tmp_tlshark_path)
        os.mkdir(tmp_cloned_path)
        os.mkdir(tmp_captured_path)
        os.mkdir(tmp_captured_path + "verbose_captured_certs/")
        os.mkdir(tmp_captured_path + "cerlog_captured_certs/")
    except FileExistsError:
        pass

    try:
        os.mkdir(json_path)
        os.mkdir(json_path + "verbose_json/")
        os.mkdir(json_path + "cerlog_json/")
    except FileExistsError:
        pass




    ## VERBOSE MODE
    ###-----------------------------------------------------------------------------------------------------------------------------------
    if mode == '100000':

        # Hndler
        def handler(signum, frame):
            print('\n\n' + "                          " + underwhite + "Generating json file . . ." + reset_undercolor)
            now = datetime.datetime.now()
            date_now = now.strftime("%y%m%d-%H%M%S")
            json_file_name = json_path + "verbose_json/" + date_now + "_verbose.json"
            with open(json_file_name,'w') as f:
                json.dump(json_file,f, indent=4)
            print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')

        signal.signal(signal.SIGINT, handler)


        # Preliminars
        json_file = {} # json dic

        # Display filter
        filter_type,display_filter = func.display_filter_manager(aux_info,args.c,args.cip,args.sip,args.ip,args.sp)
    
        if pcap_path:
            tls_cap = psk.FileCapture(pcap_path, display_filter=display_filter)
        else:
            tls_cap = psk.LiveCapture(interface=eth_interface, display_filter=display_filter)
            tls_cap = tls_cap.sniff_continuously()

        # Initializing packet capture
        ind = 0 # Packet index
        for raw_packet in tls_cap:

            server = False # Server info in this packet?
            handshake_types = func.handshake_messages(raw_packet) # Types of handshake message in the packet
        

            #----------------------------------------------- Client information -----------------------------------------------
            if (filter_type == 1 or filter_type == 3 or filter_type == 4 or filter_type == 6) and ('Client Hello (1)' in handshake_types): 
                
                # Starting phrase
                starting_phrase = red +"PACKET FOUND NUMBER: " + str(ind) + "  -->  Client Hello (1)"
                print(starting_phrase + reset_color + "\n")

                # Details
                first_details,second_details,third_details,f_head,s_head,t_head = func.basic_details(raw_packet)
                
                # Cipher suite
                result,color_result,ciph_head,cipher_error = func.match_result(raw_packet)
                
                # Json  
                new_packet = {
                                "connection_details":first_details,
                                "tls_details":second_details,
                                "hash_algorithms_and_eliptic_curves":third_details,
                                "cipher_suites":result
                            }

                packet_index = "packet_num_" + str(ind) 
                json_file[packet_index] = {"main_tls_messages": 'Client Hello (1)', "content": new_packet}
                
                # Prints
                #---------------------------- First details print --------------------------- 
                if first_details:
                    f_print = {}
                    for key in first_details.keys():
                        f_print[key]=[first_details[key]]
                    
                    print(tabulate(f_print,headers=f_head,
                                tablefmt='fancy_grid',stralign='center',numalign='center'))
                    print('\n')

                #--------------------------- Second details print --------------------------
                if second_details:
                    print(tabulate(second_details,headers=s_head,tablefmt='github'))
                    print('\n')

                #-------------------------- Cipher details print ---------------------------
                if color_result: 
                    if cipher_error:
                        print(underred + "ERROR:" + reset_undercolor + " The cipher suite with the code ['{}']  is not found in the dictionary!".format(cipher_error))
                        print("\n")
                        
                    print(tabulate(color_result, headers=ciph_head))
                    print('\n')
                
                #--------------------------- Third details print --------------------------- 
                if third_details:
                    aux_details1 = []
                    aux_details2 = []
                    for field in third_details['signature_hash_algorithms']:
                        aux_details1.append(field['code'] + " - " + field['algorithm'])
                    for field in third_details['elliptic_groups']:
                        aux_details2.append(field['code'] + " - " + field['elliptic_group'])
                    
                    third_details = {'signature_hash_algorithms':aux_details1, 'elliptic_groups':aux_details2}
                        
                    print(tabulate(third_details,headers=t_head,showindex=True,
                                tablefmt='fancy_grid',stralign='left'))
                    print("\n")  
                #------------------------------ End prints ----------------------------------

                ind += 1
                print(undergrey + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-   END OF PACKET   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n" + reset_undercolor)
                print("\n\n\n")


            #----------------------------------------------- Server information -----------------------------------------------
            if (filter_type == 2 or filter_type == 3 or filter_type == 5 or filter_type == 6) and ('Server Hello (2)' in handshake_types): 
                
                server = True
                
                # Starting phrase
                starting_phrase = red +"PACKET FOUND NUMBER: " + str(ind) + "  -->  Server Hello (2)"
                if ('Certificate (11)' in handshake_types) and args.c:
                    starting_phrase = starting_phrase + " + Certificate (11)" 
                print(starting_phrase + reset_color + "\n")

                # Details
                first_details,second_details,third_details,f_head,s_head,t_head = func.basic_details(raw_packet)
                
                # Cipher suite
                result,color_result,ciph_head,cipher_error = func.match_result(raw_packet)
                
                # Json  
                new_packet = {
                                "connection_details":first_details,
                                "tls_details":second_details,
                            }

                if 'Server Key Exchange (12)' in handshake_types:
                    new_packet["hash_algorithms_and_elliptic_curves"] = third_details

                new_packet["cipher_suites"] = result[0]
                
                # Prints
                #---------------------------- First details print ---------------------------
                if first_details:
                    f_print = {}
                    for key in first_details.keys():
                        f_print[key]=[first_details[key]]
                    
                    print(tabulate(f_print,headers=f_head,
                                tablefmt='fancy_grid',stralign='center',numalign='center'))
                    print('\n')

                #--------------------------- Second details print ---------------------------
                if second_details:
                    print(tabulate(second_details,headers=s_head,tablefmt='github'))
                    print('\n')
                
                #--------------------------- Cipher details print ---------------------------
                if color_result:
                    if cipher_error:
                        print(underred + "ERROR:" + reset_undercolor + " The cipher suite with the code ['{}']  is not found in the dictionary!".format(cipher_error))
                        print("\n")
                    else:
                        print(tabulate(color_result, headers=ciph_head))
                        print('\n')
                    
                #---------------------------- Third details print ---------------------------
                if third_details:
                    aux_details1 = [(third_details['signature_hash_algorithms']['code'] + " - " 
                    + third_details['signature_hash_algorithms']['algorithm'])]
                    
                    aux_details2 = [(third_details['elliptic_groups']['code'] + " - " 
                    + third_details['elliptic_groups']['elliptic_group'])]
                    
                    third_details = {'signature_hash_algorithms':aux_details1, 'elliptic_groups':aux_details2}
                        
                    print(tabulate(third_details,headers=t_head,showindex=True,
                    tablefmt='fancy_grid',stralign='left'))
                    print('\n') 
                
                #------------------------------ End prints ----------------------------------
                
                # Json if certificate info is not required or don't exists
                if not('Certificate (11)' in handshake_types) or not(args.c):
                    packet_index = "packet_num_" + str(ind) 
                    json_file[packet_index] = {"main_tls_mensajes": 'Server Hello (2)', "content": new_packet}
                    ind += 1
                    print(undergrey + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-   END OF PACKET   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n" + reset_undercolor)
                    print("\n\n\n")
                    
            
            #----------------------------------------------- Certificate information -----------------------------------------------
            if (filter_type == 4 or filter_type == 5 or filter_type == 6) and ('Certificate (11)' in handshake_types): 

                if server:
                    # Certificate details
                    cert_details,cert_details_to_print,c_head = func.cert_info(raw_packet,mode) # Use cert_info --> store_cert.
                    
                    #------------------------------ Cert details print ----------------------------------
                    if cert_details_to_print:
                        print('\n' + underwhite + "Certificate info:" + reset_undercolor + '\n')
                        print(cian)
                        print(tabulate(cert_details_to_print,headers=c_head, 
                                    tablefmt='orgtbl',stralign='center',numalign='center'))
                        print(reset_color)
                    #---------------------------------- End prints --------------------------------------

                    # Json
                    packet_index = "packet_num_" + str(ind)
                    new_packet["certificate_details"] = cert_details 
                    json_file[packet_index] = {"main_tls_mensajes": 'Server Hello (2) + Certificate (11)', "content": new_packet}
                    ind += 1
                    print(undergrey + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-   END OF PACKET   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n" + reset_undercolor)
                    print('\n\n\n')

                else:
                    # Starting phrase
                    starting_phrase = red +"PACKET FOUND NUMBER: " + str(ind) + "  -->  Certificate (11)"
                    print(starting_phrase + reset_color + "\n")
                    type_info = "Certificate (11)" 
                    
                    # Details 
                    first_details,second_details,third_details,f_head,s_head,t_head = func.basic_details(raw_packet)
                    
                    # Certificate details
                    cert_details,cert_details_to_print,c_head = func.cert_info(raw_packet,mode) # Use cert_info --> store_cert.
                    
                    # Json
                    new_packet = {
                                    "connection_details":first_details,
                                    "tls_details":second_details,
                                    "certificate_details":cert_details,   
                                }
                    if 'Server Key Exchange (12)' in handshake_types:
                        new_packet["hash_algorithms_and_elliptic_curves"] = third_details
                    
                    packet_index = "packet_num_" + str(ind) 
                    json_file[packet_index] = {"main_tls_mensajes": 'Certificate (11)', "content": new_packet}
                    
                    
                    # Prints
                    #----------------------------- First details print ----------------------------------
                    if first_details:
                        f_print = {}
                        for key in first_details.keys():
                            f_print[key]=[first_details[key]]
                        
                        print(tabulate(f_print,headers=f_head,
                                    tablefmt='fancy_grid',stralign='center',numalign='center'))
                        print('\n')

                    #----------------------------- Second details print ---------------------------------
                    if second_details:
                        print(tabulate(second_details,headers=s_head,tablefmt='github'))
                        print('\n')

                    #---------------------------- Third details print ---------------------------
                    if third_details:
                        aux_details1 = [(third_details['signature_hash_algorithms']['code'] + " - " 
                        + third_details['signature_hash_algorithms']['algorithm'])]
                        
                        aux_details2 = [(third_details['elliptic_groups']['code'] + " - " 
                        + third_details['elliptic_groups']['elliptic_group'])]
                        
                        third_details = {'signature_hash_algorithms':aux_details1, 'elliptic_groups':aux_details2}
                            
                        print(tabulate(third_details,headers=t_head,showindex=True,
                        tablefmt='fancy_grid',stralign='left'))
                        print('\n') 
                    
                    #------------------------------ Cert details print ----------------------------------
                    if cert_details_to_print:
                        print('\n' + underwhite + "Certificate info:" + reset_undercolor + '\n')
                        print(cian)
                        print(tabulate(cert_details_to_print,headers=c_head, 
                                    tablefmt='orgtbl',stralign='center',numalign='center'))
                        print(reset_color)              
                    #---------------------------------- End prints --------------------------------------

                    ind += 1
                    print(undergrey + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-   END OF PACKET   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n" + reset_undercolor)
                    print('\n\n\n')



        # Storing json in pcap mode
        if pcap_path:
            print('\n\n' + "                          " + underwhite + "Generating json file . . ." + reset_undercolor)
            now = datetime.datetime.now()
            date_now = now.strftime("%y%m%d-%H%M%S")
            json_file_name = json_path + "verbose_json/" + date_now + "_verbose.json"
            with open(json_file_name,'w') as f:
                json.dump(json_file,f, indent=4)




    ## CERLOG MODE
    ###------------------------------------------------------------------------------------------------------------------------------------
    elif mode == '010000':

        # Handler
        def handler(signum, frame):
            print('\n' + "                                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')   
            exit()

        signal.signal(signal.SIGINT, handler)

        # Preliminars
        colors = [white,grey,blue,yellow,green,cian,purple] 
        undercolors = [underwhite,undergrey,underblue,underyellow,undergreen,undercian,underpurple] 
        k = 0 # Color index for each connection.
        connections = [] # Connection objects list.
        ids = [] # List with the IDs (port of the Client machine) for each connection.


        # Display filter
        filter_type,display_filter = func.display_filter_manager('001',True,args.cip,args.sip,'',args.sp)  

        if pcap_path:
            tls_cap = psk.FileCapture(pcap_path, display_filter=display_filter)
        else:
            tls_cap = psk.LiveCapture(interface=eth_interface, display_filter=display_filter)
            tls_cap = tls_cap.sniff_continuously()    


        # Initializing packet capture
        for raw_packet in tls_cap:
            tls_messages = func.handshake_messages(raw_packet)

            # CAPTURE SERVER INFO  
            # Client Hello detected
            if "Client Hello (1)" in tls_messages:

                # Preliminars
                id = raw_packet[raw_packet.transport_layer].srcport
                server_port = raw_packet[raw_packet.transport_layer].dstport
                ids.append(id)


                # common_name
                if (raw_packet.tls.has_field('handshake_extension_type') and # There are extensions and ...
                    '<LayerField tls.handshake.extension.type: 0>' in str(raw_packet.tls.handshake_extension_type.all_fields)):# There is the server_name extension.

                    server_name = raw_packet.tls.handshake_extensions_server_name.showname_value

                else: 
                    server_name = "There is no common name" 


                # Storing data
                conn = func.Connection()
                conn.set_server_name(server_name)
                conn.set_id(id)
                conn.add_control('Client Hello')
                conn.set_ip_client(raw_packet.ip.src)
                conn.set_ip_server(raw_packet.ip.dst)
                conn.set_server_port(server_port)
                color = colors[k]                
                undercolor = undercolors[k]
                if k >= 6: k = 0
                else: k = k+1
                conn.set_color(color)
                conn.set_undercolor(undercolor)
                connections.append(conn)
                

                # New connection
                print("\n\n\n")
                print(undercolor + 
                    "*  NEW CONNECTION  ---> ID: " + str(id) + "    " + "Client: " + conn.ip_client + ":" + id + 
                    ",  Server: " + server_name + ":" + server_port + " ("+ conn.ip_server + ")  *" + reset_undercolor + "\n\n")
                print(color + "Client Hello has been detected, ID:" + str(id) +  reset_color + "\n")


            # Server Hello detected
            if ("Server Hello (2)" in tls_messages) and (raw_packet[raw_packet.transport_layer].dstport in ids):

                # Preliminars
                id =raw_packet[raw_packet.transport_layer].dstport
                ind = ids.index(id)
                chosen_suite,b,c,cipher_error = func.match_result(raw_packet)

                # Storing data 
                if cipher_error:
                    print(underred + "ERROR:" + reset_undercolor 
                        + " Server Hello has been detected, but the cipher suite with the code ['{}']  is not found in the dictionary!".format(cipher_error))
                    connections[ind].set_cipher_code_error(cipher_error)
                
                else:     
                    connections[ind].set_chosen_cipher_suite(chosen_suite[0]["cipher_suite"])
                    connections[ind].add_control('Server Hello')
                    chosen_tls_version = func.tls_versions(raw_packet)[0]
                    connections[ind].set_chosen_tls_version(chosen_tls_version)
                    
                    print(connections[ind].color + "Server Hello has been detected, ID:" + str(id) + 
                        ", TLS version and Cipher Suite selected by the Server has been collected..." + reset_color + "\n")


            # Server Certificate detected
            if ("Certificate (11)" in tls_messages) and (raw_packet[raw_packet.transport_layer].dstport in ids):
                
                # Preliminars
                id = raw_packet[raw_packet.transport_layer].dstport
                ind = ids.index(id)
                
                if not(connections[ind].cipher_code_error):

                    # If the secuence is complete
                    if (id in ids) and (('Client Hello' and 'Server Hello') in connections[ind].control):

                        print(connections[ind].color + "Server Certificate has been detected, ID:" 
                        + str(id) + ", the Server's certificates have been collected ..." + reset_color + "\n")

                        # Stroing captured certificates data
                        cert_details,b,c = func.cert_info(raw_packet,mode) # Use cert_info --> store_cert.
                        pem_chain = cert_details["certificates"]
                        connections[ind].set_pem_chain(pem_chain) 
                        connections[ind].add_control('Certificate') 

                        print(color + "                           --------   ID: " 
                        + str(id) + "    SEQUENCE: COMPLETED!  --------" + reset_color + "\n")


                        # Storing data in a json dictionary.
                        json_file_name = "cerlog_ID_" + str(id) + ".json"
                        folder_path = json_path + "cerlog_json/" 
                        file_path = folder_path + json_file_name

                        if os.path.exists(file_path):
                            response = input('\n' + underred + "ERROR:" + reset_undercolor + " The file: " + underwhite + json_file_name
                                + reset_undercolor + " in path: " + file_path + " already exist. Do you want to overwrite it? (y/n): ")
                            print('\n')
                            
                            while (response != 'y') and (response != 'n'):
                                response = input('\n' + underred + "ERROR:" + reset_undercolor 
                                    + " You must to choose 'y' or 'n'. Do you want to overwrite it? (y/n): ")
                                print('\n')

                            if response == 'y':
                                os.remove(file_path)
                                generate_json_file = True

                            elif response == 'n':
                                generate_json_file  = False
                                print(red + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*   ID: " 
                                + str(id) + "    CERTIFICATES: NOT CLONED   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*" + reset_color + "\n")
                                print(red + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*   ID: " 
                                + str(id) + "    JSON FILE: NOT GENERATED    *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*" + reset_color + "\n")
                                

                        else:
                            generate_json_file  = True


                        if generate_json_file:

                            ip_and_server_port = connections[ind].ip_server + ":" + connections[ind].server_port
                            tls_version = str(connections[ind].chosen_tls_version)
                            c_name = cert_details["c_name"][0]
                            cipher_suite = str(connections[ind].chosen_cipher_suite)
                            ori_pem_chain = connections[ind].pem_chain
                        

                            to_hash_string = ip_and_server_port + tls_version + c_name + cipher_suite + "".join(ori_pem_chain)
                            to_hash_bytes = bytes(to_hash_string,'utf-8')
                            file_hash = func.sha256(to_hash_bytes)

                            
                            json_file = {
                                            "Impersonation server data" :{
                                                "ID": str(id),
                                                "IP and Server port": ip_and_server_port,
                                                "TLS version": tls_version,
                                                "C_Name": c_name,
                                                "Sha256": file_hash,
                                                "Cipher suite": cipher_suite,
                                                "Original Certificates": "".join(ori_pem_chain),
                                            }}

                            # Clonning original pem chain certs.
                            cloned_pem_chain,private_key = func.clone_cert(id)
                            
                            print(color + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*   ID: " 
                            + str(id) + "    CERTIFICATES: CLONED   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*" + reset_color + "\n") 
                            json_file["Impersonation server data"]["Cloned certificates"] = cloned_pem_chain
                            json_file["Impersonation server data"]["Private key"] = private_key

                            # Storing json in a cerlog_ID_id.json file
                            with open(file_path,'w') as f:
                                json.dump(json_file,f,indent=4, separators=(',', ':'))
                            
                            print(color + "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*   ID: " 
                            + str(id) + "    JSON FILE: GENERATED   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*" + reset_color + "\n")

                        print(color + "[*][*][*][*][*][*][*][*][*][*][*][*][*][*][*]  ID: " 
                        + str(id) + "   SUCCESFULL END!  [*][*][*][*][*][*][*][*][*][*][*][*][*][*][*]" + reset_color + "\n")
                
                if connections[ind].cipher_code_error:
                    print(red + "[*][*][*][*][*][*][*][*][*][*][*][*][*][*][*]  ID: " 
                    + str(id) + "   UNSUCCESFULL END!  [*][*][*][*][*][*][*][*][*][*][*][*][*][*][*]" + reset_color + "\n")




    ## ROGUE MODE
    ###-----------------------------------------------------------------------------------------------------------------------------------
    elif mode == '001000':
        try:
            
            # EXTRACT CERLOG JSON DATA
            ids = []
            c_names = []
            ip_ports = []
            hashes = []
            tls_versions = []
            cipher_suites = []
            cloned_cert_chains = []
            private_keys = []


            if args.json:
                json_file = args.json
                with open(json_file,'r') as json_f:
                    file = json.load(json_f) 

                file = file["Impersonation server data"]
                ids.append(file['ID'])
                ip_ports.append(file['IP and Server port'])
                tls_versions.append(file['TLS version'])
                c_names.append(file['C_Name'])
                hashes.append(file['Sha256'])
                cipher_suites.append(file['Cipher suite'])
                cloned_cert_chains.append(file["Cloned certificates"])
                private_keys.append(file["Private key"])

            else:
                sup_servs = os.listdir(json_path + "/cerlog_json/")

                if sup_servs:
                    for sup_serv in sup_servs:
                        json_file = json_path + "/cerlog_json/" + sup_serv
                        with open(json_file,'r') as json_f:
                            file = json.load(json_f)  
                        
                        file = file["Impersonation server data"]
                        ids.append(file['ID'])
                        ip_ports.append(file['IP and Server port'])
                        tls_versions.append(file['TLS version'])
                        c_names.append(file['C_Name'])
                        hashes.append(file['Sha256'])
                        cipher_suites.append(file['Cipher suite'])
                        cloned_cert_chains.append(file["Cloned certificates"])
                        private_keys.append(file["Private key"])
                else:
                    print(underred + "ERROR:" + reset_undercolor + " Cerlog json folder is empty, you must fill it by running cerlog mode or use -json. ")
                    print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
                    exit()

                


            # PRINTING DATA TO CHOOSE A IMPERSONATED SERVER.   
            print("\n\n" + "List of impersonated servers: " + "\n")

            servers_list = {"ID": ids, "Servers": c_names, "IP_Port": ip_ports, "Hash": hashes}
            print(tabulate(servers_list, headers=["ID", "C_Name", "IP and port", "Sha256"], showindex=True,tablefmt='orgtbl',stralign='left',numalign='center'))

            print("\n" + "Impersonated server Num: ", end="")
            server = int(input())

            ind = range(len(ids))
            while server not in ind:
                print("\n\n" + "Choose a server from the list!" + "\n\n")
                print("List of impersonated servers: " + "\n")
                print(tabulate(servers_list, headers=["ID", "C_Name", "IP and port", "Sha256"], showindex=True,tablefmt='orgtbl',stralign='left',numalign='center'))
                print("\n" + "Impersonated server Num: ", end="")
                server = int(input())
            

            # READING DATA FROM THE SELECTED SERVER JSON FILE. 
            port = ip_ports[server].split(":")[1]
            aux = tls_versions[server] 
            c_name = c_names[server]   
            tls_cipher_suite = cipher_suites[server]   

            if aux == "TLSv1.0": tls_version = ' -tls1'  
            elif aux == "TLSv1.1": tls_version = ' -tls1_1'
            elif aux == "TLSv1.2": tls_version = ' -tls1_2'

            ssl_index = dictionary["tls_ciphers"].index(tls_cipher_suite)
            ssl_cipher_suite = dictionary["ssl_ciphers"][ssl_index]
            if ssl_cipher_suite == 'none':
                print(underred + "ERROR:" + reset_undercolor + " There is no translation to ssl format of the cipher suite: "
                    + underwhite + tls_cipher_suite + reset_undercolor + " in Dictionary . . .")
                print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
                exit()

            cloned_cert_chain = cloned_cert_chains[server]
            private_key = private_keys[server]
            cloned_path = tmp_tlshark_path + "/cloned_certs/"

            command = "openssl s_server " + tls_version + ' -cipher ' + ssl_cipher_suite + " -port " + port
            num_certs = cloned_cert_chain.count("-----BEGIN CERTIFICATE-----")
            if num_certs > 1:
                cert_list = []
                for cert in cloned_cert_chain.split("-----BEGIN CERTIFICATE-----"):
                    cert_list.append("-----BEGIN CERTIFICATE-----" + cert)

                now = datetime.datetime.now() 
                hour_now = now.strftime("%H%M%S")
                ubi_cert = cloned_path + hour_now + "_cloned_cert.pem"
                ubi_chain = cloned_path + hour_now + "_cloned_chain.pem"
                ubi_key = cloned_path + hour_now + "_cloned_PrivK.key"
                with open(ubi_cert,'w') as cloned_cert:
                    cloned_cert.write(cert_list[1])
                with open(ubi_chain,'w') as cloned_chain:
                    cloned_chain.write("".join(cert_list[2:]))
                with open(ubi_key,'w') as pk:
                    pk.write(private_key)

                command +=   " -key " + ubi_key + " -cert " + ubi_cert + " -cert_chain " + ubi_chain

            
            else:
                now = datetime.datetime.now() 
                hour_now = now.strftime("%H%M%S")
                ubi_cert = cloned_path + hour_now + "_cloned_cert.pem"
                ubi_key = cloned_path + hour_now + "_cloned_PrivK.key"
                with open(ubi_cert,'w') as cloned_cert:
                    cloned_cert.write(cloned_cert_chain)
                with open(ubi_key,'w') as pk:
                    pk.write(private_key)
                command +=   " -key " + ubi_key + " -cert " + ubi_cert 

            
            # RAISING THE SERVER
            print(white + "Raising impersonating " + c_name + " Server." + reset_color + '\n')
            os.system(command)
            
        except KeyboardInterrupt:
            print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
            pass




    ## TRANSPARENT MITMPROXY MODE
    ###-----------------------------------------------------------------------------------------------------------------------------------
    elif mode == '000100': 
        try:

            # EXTRACT CERLOG JSON DATA
            ids = []
            c_names = []
            ip_ports = []
            hashes = []
            cipher_suites = []
            tls_versions = []
            cloned_cert_chains = []
            private_keys = []


            if args.json:
                json_file = args.json
                with open(json_file,'r') as json_f:
                    file = json.load(json_f) 

                file = file["Impersonation server data"]
                ids.append(file['ID'])
                ip_ports.append(file['IP and Server port'])
                tls_versions.append(file['TLS version'])
                c_names.append(file['C_Name'])
                hashes.append(file['Sha256'])
                cipher_suites.append(file['Cipher suite'])
                cloned_cert_chains.append(file["Cloned certificates"])
                private_keys.append(file["Private key"])

            else:
                sup_servs = os.listdir(json_path + "/cerlog_json/")

                if sup_servs:
                    for sup_serv in sup_servs:
                        json_file = json_path + "/cerlog_json/" + sup_serv
                        with open(json_file,'r') as json_f:
                            file = json.load(json_f)  
                        
                        file = file["Impersonation server data"]
                        ids.append(file['ID'])
                        ip_ports.append(file['IP and Server port'])
                        tls_versions.append(file['TLS version'])
                        c_names.append(file['C_Name'])
                        hashes.append(file['Sha256'])
                        cipher_suites.append(file['Cipher suite'])
                        cloned_cert_chains.append(file["Cloned certificates"])
                        private_keys.append(file["Private key"])
                else:
                    print(underred + "ERROR:" + reset_undercolor + " Cerlog json folder is empty, you must fill it by running cerlog mode or use -json. ")
                    print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
                    exit()

            # PRINTING DATA TO CHOOSE A MITM PROXY.   
            print("\n\n" + "  List of mitm proxies: " + "\n")

            servers_list = {"ID": ids, "Mitm proxies": c_names, "IP_Port": ip_ports, "Hash": hashes}
            print(tabulate(servers_list, headers=["ID", "C_Name", "IP and port", "Sha256"], showindex=True,tablefmt='orgtbl',stralign='left',numalign='center'))

            print("\n" + "Mitm proxy Num: ", end="")
            server = int(input())

            ind = range(len(ids))
            while server not in ind:
                print("\n\n" + "  Choose a proxy from the list!" + "\n\n")
                print("  List of mitm proxies: " + "\n")
                print(tabulate(servers_list, headers=["ID","C_Name", "IP and port", "Sha256"], showindex=True,tablefmt='orgtbl',stralign='left',numalign='center'))
                print("\n" + "Mitm proxy Num: ", end="")
                server = int(input())


            # READING DATA FROM A JSON FILE.
            port = ip_ports[server].split(":")[1] 
            aux = tls_versions[server]  
            if aux == "TLSv1.0": tls_version = 'TLS1'  
            elif aux == "TLSv1.1": tls_version = 'TLS1_1'
            elif aux == "TLSv1.2": tls_version = 'TLS1_2'
            
            tls_cipher_suite = cipher_suites[server]
            ssl_index = dictionary["tls_ciphers"].index(tls_cipher_suite)
            ssl_cipher_suite = dictionary["ssl_ciphers"][ssl_index]
            
            if ssl_cipher_suite == 'none':
                print(underred + "ERROR:" + reset_undercolor + " There is no translation to ssl format of the cipher suite: "
                    + underwhite + tls_cipher_suite + reset_undercolor + " in Dictionary . . .")
                print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
                exit()


            if certfrom_mode == '100':
                cloned_cert_chain = cloned_cert_chains[server]
                cloned_cert_chain = cloned_cert_chain.split("\n")
                n=0
                k=0
                certs = []
                while k<len(cloned_cert_chain):
                    cert,n = func.txt_extractor(cloned_cert_chain[k:],"-----BEGIN CERTIFICATE-----","-----END CERTIFICATE-----")
                    k += n+1
                    certs.append(cert)

                cloned_cert_chain = []
                for cert in certs:
                    cloned_cert_chain += cert    
                cloned_cert_chain = '\n'.join(cloned_cert_chain)
                
                private_key = private_keys[server]
                private_key = private_key.split("\n")
                private_key,n = func.txt_extractor(private_key,"-----BEGIN RSA PRIVATE KEY-----","-----END RSA PRIVATE KEY-----")
                private_key = '\n'.join(private_key)
                
                cloned_path = tmp_tlshark_path + "/cloned_certs/"
                now = datetime.datetime.now() 
                hour_now = now.strftime("%H%M%S") 
                ubi_cert = cloned_path + hour_now + "_proxy_cert.pem"
                with open(ubi_cert,'w') as cloned_cert:
                    cloned_cert.write(private_key)
                    cloned_cert.write('\n')
                    cloned_cert.write(cloned_cert_chain)
                command_mitm = "mitmproxy --mode transparent --showhost --certs " + ubi_cert + " --set tls_version_client_max=" + tls_version + " --set ciphers_client=" + ssl_cipher_suite

            elif certfrom_mode == '010':
                command_mitm = "mitmproxy --mode transparent --showhost --set tls_version_client_max=" + tls_version + " --set ciphers_client=" + ssl_cipher_suite

            elif certfrom_mode == '001':
                command_mitm = "mitmproxy --mode transparent --showhost --certs " + args.certfrom_path + " --set tls_version_client_max=" + tls_version + " --set ciphers_client=" + ssl_cipher_suite


            # Enabling traffic forwarding and port forwarding.
            command1 = "sudo sysctl -w net.ipv4.ip_forward=1" # Enable traffic forwarding.
            command2 = "sudo sysctl -w net.ipv4.conf.all.send_redirects=0" # Disable the use of shortest available paths,bypassing the proxy.
            command3 = "sudo iptables -t nat -A PREROUTING -i " + eth_interface + " -p tcp --dport " + port + " -j REDIRECT --to-port 8080" # Enable port forwarding.

            print("\n" + white + "Enabling traffic forwarding" + reset_color)
            os.system(command1)
            print("\n" + white + "Disabling the use of shortest available paths, bypassing the proxy..." + reset_color)
            os.system(command2)
            print("\n" + white + "Enabling port forwarding, port " + port + " ---> port 8080." + reset_color)
            os.system(command3)
            

            # RAISING THE PROXY
            print("\n" + white + "Raising a transparent proxy for the domain: " + c_names[server] + "," + '\n' 
                  + "with TLS version: " + tls_version + ", and Cipher Suite: " + ssl_cipher_suite + reset_color)
            time.sleep(2)
            os.system(command_mitm)
            
            # Disabling traffic forwarding and port forwarding.
            command1 = "sudo sysctl -w net.ipv4.ip_forward=0" # Disable traffic forwarding.
            command2 = "sudo sysctl -w net.ipv4.conf.all.send_redirects=1" # Enable the use of shortest available paths by bypassing the proxy.
            command3 = "sudo iptables -t nat -F" # Disable port forwarding.

            print("\n" + white + "Disabling traffic forwarding..." + reset_color)
            os.system(command1)
            print("\n" + white + "Enabling the use of shortest available paths, bypassing the proxy..." + reset_color)
            os.system(command2)
            print("\n" + white + "Disabling port forwarding..." + reset_color)
            os.system(command3)

            print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
        
        except KeyboardInterrupt:
            print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
            pass




    ## REVERSE MITMPROXY MODE
    ###-----------------------------------------------------------------------------------------------------------------------------------
    elif mode == '000010': 
        command = "mitmproxy -p 443 --mode reverse:https://" + args.url
        print("\n" + white + "Raising a mitm reverse proxy for the domain: " + args.url + reset_color)
        time.sleep(2)
        os.system(command)
        print('\n\t\t\t' + white + "EXIT!" + reset_color)
        exit()




    ## TLS VERSION DETECTOR MODE
    ###-----------------------------------------------------------------------------------------------------------------------------------
    elif mode == '000001':
        
        try:
            # EXTRACT CERLOG JSON DATA
            p = ''
            ids = []
            c_names = []
            ip_ports = []
            hashes = []
            cloned_cert_chains = []
            private_keys = []

            # If the -json flag is set
            if args.json:
                json_file = args.json
                with open(json_file,'r') as json_f:
                    file = json.load(json_f) 

                file = file["Impersonation server data"]
                ids.append(file['ID'])
                ip_ports.append(file['IP and Server port'])
                c_names.append(file['C_Name'])
                hashes.append(file['Sha256'])
                cloned_cert_chains.append(file["Cloned certificates"])
                private_keys.append(file["Private key"])

            # If the -json flag is not set
            else:
                sup_servs = os.listdir(json_path + "/cerlog_json/")

                if sup_servs:
                    for sup_serv in sup_servs:
                        json_file = json_path + "/cerlog_json/" + sup_serv
                        with open(json_file,'r') as json_f:
                            file = json.load(json_f)  
                        
                        file = file["Impersonation server data"]
                        ids.append(file['ID'])
                        ip_ports.append(file['IP and Server port'])
                        c_names.append(file['C_Name'])
                        hashes.append(file['Sha256'])
                        cloned_cert_chains.append(file["Cloned certificates"])
                        private_keys.append(file["Private key"])
                else:
                    print(underred + "ERROR:" + reset_undercolor + " Cerlog json folder is empty, you must fill it by running cerlog mode or use -json. ")
                    print('\n' + "                                   " + underwhite + "EXIT!" + reset_undercolor + '\n')
                    exit()

                
            # PRINTING DATA TO CHOOSE A IMPERSONATED SERVER.   
            print("\n\n" + "List of servers: " + "\n")
            
            ips = [x.split(":")[0] for x in ip_ports]
            servers_list = {"ID": ids, "Servers": c_names, "IP": ips, "Hash": hashes}
            print(tabulate(servers_list, headers=["ID", "C_Name", "IP", "Sha256"], showindex=True,tablefmt='orgtbl',stralign='left',numalign='center'))

            print("\n" + "Server Num: ", end="")
            server = int(input())

            ind = range(len(ids))
            while server not in ind:
                print("\n\n" + "Choose a server from the list!" + "\n\n")
                print("List of servers: " + "\n")
                print(tabulate(servers_list, headers=["ID", "C_Name", "IP", "Sha256"], showindex=True,tablefmt='orgtbl',stralign='left',numalign='center'))
                print("\n" + "Server Num: ", end="")
                server = int(input())
            

            # READING DATA FROM THE SELECTED SERVER JSON FILE. 
            c_name = c_names[server]   
            cloned_cert_chain = cloned_cert_chains[server]
            private_key = private_keys[server]
            cloned_path = tmp_tlshark_path + "/cloned_certs/"
           
            now = datetime.datetime.now() 
            hour_now = now.strftime("%H%M%S")
            ubi_cert = cloned_path + hour_now + "_cloned_cert.pem"
            ubi_key = cloned_path + hour_now + "_cloned_PrivK.key"
            with open(ubi_cert,'w') as cloned_cert:
                cloned_cert.write(cloned_cert_chain)
            with open(ubi_key,'w') as pk:
                pk.write(private_key)
            
            print('\n' + white + "Raising " + c_name + " server" + reset_color)
            
            # TLS DETECTOR
            tls_flags = (' -tls1_3', ' -tls1_2', ' -tls1_1', ' -tls1')
            tls_versions = ['TLSv1.3','TLSv1.2','TLSv1.1','TLSv1']
            tls_supported = []
            
            command = "openssl s_server -4 -port 443 -key " + ubi_key + " -cert " + ubi_cert
            
            for j,tls_flag in enumerate(tls_flags):
                tls_command = command + tls_flag
                p = subprocess.Popen(tls_command,shell=True,universal_newlines=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
                lines = []
                print('\n' + purple + "NEW CONNECTION: " + white + tls_versions[j] + reset_color)
                for n,out in enumerate(p.stdout):
                    lines.append(out.rstrip())
    
                    if ("unsupported protocol" in lines[n]) or ("wrong version number" in lines[n]):
                        print(white + "Unsuported "+ tls_versions[j]  +" protocol" + '\n' + purple + "CLOSED CONNECTION" + reset_color)
                        func.kill_sons(os.getpgid(p.pid))
                        tls_supported.append(False)
    
                    elif ("unknown ca" in lines[n]) or ("Secure Renegotiation IS supported" in lines[n]):
                        print(white + "Supported "+ tls_versions[j]  +" protocol" + '\n' + purple + "CLOSED CONNECTION" + reset_color)
                        func.kill_sons(os.getpgid(p.pid))
                        tls_supported.append(True)
            
            print('\n')    
            to_print = [["TLS version: "] + tls_versions,["Supported version: "] + tls_supported]
            print(white)
            print(tabulate(to_print,tablefmt='fancy_grid',stralign='center'))
            print(reset_color)

        except KeyboardInterrupt:
            if p: func.kill_sons(os.getpgid(p.pid))
            print('\n\t\t\t' + white + "EXIT!" + reset_color)
            exit()
   
        


if __name__ == "__main__":
    main()
    
    
    
    
    
